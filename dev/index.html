<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · SimpleChecksums.jl</title><meta name="title" content="Home · SimpleChecksums.jl"/><meta property="og:title" content="Home · SimpleChecksums.jl"/><meta property="twitter:title" content="Home · SimpleChecksums.jl"/><meta name="description" content="Documentation for SimpleChecksums.jl."/><meta property="og:description" content="Documentation for SimpleChecksums.jl."/><meta property="twitter:description" content="Documentation for SimpleChecksums.jl."/><meta property="og:url" content="https://reallyasi9.github.io/SimpleChecksums.jl/"/><meta property="twitter:url" content="https://reallyasi9.github.io/SimpleChecksums.jl/"/><link rel="canonical" href="https://reallyasi9.github.io/SimpleChecksums.jl/"/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>SimpleChecksums.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#Synopsis"><span>Synopsis</span></a></li><li><a class="tocitem" href="#Why?"><span>Why?</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/reallyasi9/SimpleChecksums.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/reallyasi9/SimpleChecksums.jl/blob/development/docs/src/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="SimpleChecksums"><a class="docs-heading-anchor" href="#SimpleChecksums">SimpleChecksums</a><a id="SimpleChecksums-1"></a><a class="docs-heading-anchor-permalink" href="#SimpleChecksums" title="Permalink"></a></h1><p>Documentation for <a href="https://github.com/reallyasi9/SimpleChecksums.jl">SimpleChecksums</a>.</p><ul><li><a href="#SimpleChecksums.additive_checksum-Union{Tuple{T}, Tuple{Type{T}, Any}, Tuple{Type{T}, Any, Unsigned}, Tuple{Type{T}, Any, Unsigned, T}} where T&lt;:Unsigned"><code>SimpleChecksums.additive_checksum</code></a></li><li><a href="#SimpleChecksums.adler32"><code>SimpleChecksums.adler32</code></a></li><li><a href="#SimpleChecksums.bsd_checksum"><code>SimpleChecksums.bsd_checksum</code></a></li><li><a href="#SimpleChecksums.fletcher_checksum-Union{Tuple{T}, Tuple{Type{T}, Any}, Tuple{Type{T}, Any, Unsigned}, Tuple{Type{T}, Any, Unsigned, T}, Tuple{Type{T}, Any, Unsigned, T, Integer}} where T&lt;:Unsigned"><code>SimpleChecksums.fletcher_checksum</code></a></li><li><a href="#SimpleChecksums.sysv_checksum"><code>SimpleChecksums.sysv_checksum</code></a></li></ul><h2 id="Synopsis"><a class="docs-heading-anchor" href="#Synopsis">Synopsis</a><a id="Synopsis-1"></a><a class="docs-heading-anchor-permalink" href="#Synopsis" title="Permalink"></a></h2><h3 id="Installation"><a class="docs-heading-anchor" href="#Installation">Installation</a><a id="Installation-1"></a><a class="docs-heading-anchor-permalink" href="#Installation" title="Permalink"></a></h3><pre><code class="language-julia hljs">using Pkg
Pkg.add(&quot;SimpleChecksums&quot;)</code></pre><h3 id="Use"><a class="docs-heading-anchor" href="#Use">Use</a><a id="Use-1"></a><a class="docs-heading-anchor-permalink" href="#Use" title="Permalink"></a></h3><pre><code class="language-julia hljs">using SimpleChecksums

data = UInt8.(0:255);

# super-simple sums:
@assert additive_checksum(UInt16, data) == additive16(data) == 0x7f80
@assert additive_checksum(UInt32, data) == additive32(data) == 0x00007f80
@assert additive_checksum(UInt64, data) == additive64(data) == 0x0000000000007f80

# BSD and SYS-V checksums from GNU sum utility:
@assert bsd_checksum(UInt16, data) == bsd16(data) == 0x0200
@assert sysv_checksum(UInt16, data) == sysv16(data) == 0x7f80

# Fletcher&#39;s and Adler&#39;s checksums:
@assert fletcher_checksum(UInt16, data) == fletcher16(data) == 0x5500
@assert fletcher_checksum(UInt32, data) == fletcher32(data) == 0xaaaa7f80
@assert fletcher_checksum(UInt64, data) == fletcher64(data) == 0x002aaa8000007f80

@assert fletcher_checksum(UInt16, data, UInt16(0), 0x100) == fletcher16a(data) == 0x8080
@assert fletcher_checksum(UInt32, data, UInt32(0), 0x10000) == fletcher32a(data) == 0xaa807f80
@assert fletcher_checksum(UInt64, data, UInt64(0), 0x100000000) == fletcher64a(data) == 0x002aaa8000007f80

@assert fletcher_checksum(UInt32, data, UInt32(1), UInt32(65521), 5552) == adler32(data) == 0xadf67f81</code></pre><h2 id="Why?"><a class="docs-heading-anchor" href="#Why?">Why?</a><a id="Why?-1"></a><a class="docs-heading-anchor-permalink" href="#Why?" title="Permalink"></a></h2><p>Checksums are small summaries of data that can be used to detect errors introduced to the data during transmission or storage. In modern times, checksums have largely been replaced with cryptographic hashes like <a href="https://github.com/JuliaCrypto/MD5.jl">MD5</a> and <a href="https://docs.julialang.org/en/v1/stdlib/SHA/">SHA</a>, but these functions and the computational power required to compute them in a reasonable amount of time did not exist when many of the data transmission and storage standards we use today were invented. If we want to use the checksums that appear in these standards in Julia code, it helps to have a standard library to compute them correctly and efficiently.</p><p>If you are building a new data transmission or storage standard and need a way to check for errors, consider using a cryptographic hash like <a href="https://docs.julialang.org/en/v1/stdlib/SHA/">SHA</a>, or at least a better error-detecting code like <a href="https://github.com/JuliaIO/CRC32.jl">CRC</a>, before choosing any of these functions.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleChecksums.additive_checksum-Union{Tuple{T}, Tuple{Type{T}, Any}, Tuple{Type{T}, Any, Unsigned}, Tuple{Type{T}, Any, Unsigned, T}} where T&lt;:Unsigned" href="#SimpleChecksums.additive_checksum-Union{Tuple{T}, Tuple{Type{T}, Any}, Tuple{Type{T}, Any, Unsigned}, Tuple{Type{T}, Any, Unsigned, T}} where T&lt;:Unsigned"><code>SimpleChecksums.additive_checksum</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">additive_checksum(T, data, init::T = zero(T), modulo::T = typemax(T)) where {T&lt;:Unsigned}</code></pre><p>Compute a simple additive hash of the values in <code>data</code>.</p><p>Sums all the values in <code>data</code>, then computes modulo <code>modulo</code>, optionally starting from <code>init</code> instead of zero. Sums are allowed to overflow, which resets the sum to zero.</p><p>This function is extremely fast but suffers from many collisions. Flaws to keep in mind are:</p><ol><li>zero values in <code>data</code> do not affect the checksum value at all;</li><li>the order of the values in <code>data</code> can be permuted without changing the checksum value; and</li><li>because of the modulo operation, the checksum of all zeros is equal to the checksum of all <code>modulo</code> values.</li></ol><p><strong>Arguments</strong></p><ul><li><code>T</code>: An unsinged integer type.</li><li><code>data</code>: A single <code>Unsigned</code> value or an iterator of values.</li><li><code>init::Unsigned = zero(T)</code>: Optional starting value.</li><li><code>modulo::T = typemax(T)</code>: A number to use as the modulo for addition. Typical choices are <code>typemax(T)</code> (the default) or some prime number close to but less than <code>typemax(T)</code>.</li></ul><p>Predefined convenience functions are <code>additive16</code>, <code>additive32</code>, and <code>additive64</code>.</p><p>See also: <code>sysv16</code> for a different way of folding the sum into a fixed number of bits.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/reallyasi9/SimpleChecksums.jl/blob/c4030151fbee5988e19050daae6fe4785b6fac41/src/additive.jl#L1-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleChecksums.adler32" href="#SimpleChecksums.adler32"><code>SimpleChecksums.adler32</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">adler32(data, init::Unsigned = one(UInt32))</code></pre><p>Compute Adler&#39;s 32-bit checksum.</p><p>Adler&#39;s 32-bit checksum is the same as Fletcher&#39;s 32-bit checksum with a modulus of 65521 (the largest 16-bit prime) and an inital value of one. This is a strict improvement on <code>fletcher16</code>, but has a higher probability of collision, worse likelihood of error detection, and is slower than <code>fletcher32</code>. Prefer <code>fletcher32</code> instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/reallyasi9/SimpleChecksums.jl/blob/c4030151fbee5988e19050daae6fe4785b6fac41/src/fletcher.jl#L71-L77">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleChecksums.bsd_checksum" href="#SimpleChecksums.bsd_checksum"><code>SimpleChecksums.bsd_checksum</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">bsd_checksum(UInt16, data, init::UInt16 = zero(UInt16))</code></pre><p>Compute a hash of <code>data</code> using the method defined in BSD&#39;s sum utility (and implemented in the GNU sum program).</p><p>The BSD checksum computes a 16-bit checksum value by bit-rotating the checksum value from the previous step to the right by 1 bit, then adding the next value from <code>data</code> and repeating. Sums are allowed to overflow, which resets the sum to zero.</p><p>This function is fast but suffers from many collisions. Flaws to keep in mind are:</p><ol><li>zero values at the beginning of <code>data</code> do not affect the checksum value at all (unless the initial value is set to something other than zero); and</li><li>runs of zeros in <code>data</code> that are multiples of 16 in length do not affect the checksum value at all.</li></ol><p><strong>Arguments</strong></p><ul><li><code>data</code>: A single <code>Unsigned</code> value or an iterator of values.</li><li><code>init::UInt16 = zero(UInt16)</code>: Optional starting value.</li></ul><p>Predefined convenience function is <code>bsd16</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/reallyasi9/SimpleChecksums.jl/blob/c4030151fbee5988e19050daae6fe4785b6fac41/src/bsd.jl#L4-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleChecksums.fletcher_checksum-Union{Tuple{T}, Tuple{Type{T}, Any}, Tuple{Type{T}, Any, Unsigned}, Tuple{Type{T}, Any, Unsigned, T}, Tuple{Type{T}, Any, Unsigned, T, Integer}} where T&lt;:Unsigned" href="#SimpleChecksums.fletcher_checksum-Union{Tuple{T}, Tuple{Type{T}, Any}, Tuple{Type{T}, Any, Unsigned}, Tuple{Type{T}, Any, Unsigned, T}, Tuple{Type{T}, Any, Unsigned, T, Integer}} where T&lt;:Unsigned"><code>SimpleChecksums.fletcher_checksum</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fletcher_checksum(T, data, init::T = zero(T), modulo::T = typemax(T), blocksize::Integer = 1)</code></pre><p>Compute a hash of <code>data</code> using Fletcher&#39;s checksum.</p><p>Fletcher&#39;s checksum computes two values: <code>c0</code>, a running sum of values modulo some number, and <code>c1</code>, a running sum of <code>c0</code> values modulo some number. The two values are contatenated bitwise into a single unsigned integer.</p><p>This function is fast and good at detecting small errors. Flaws to keep in mind are:</p><ol><li>zero values at the beginning of <code>data</code> do not affect the checksum value at all (unless the initial value is set to something other than zero); and</li><li>the worst-case performance for this algorithm occurs when data are truly random, but all errors of up to 2 bits are detected on all runs of data of length <code>modulo * (sizeof(T)*4)</code> bits.</li></ol><p><strong>Arguments</strong></p><ul><li><code>T</code>: An unsinged integer type.</li><li><code>data</code>: A single <code>Unsigned</code> value or an iterator of values.</li><li><code>init::Unsigned = zero(T)</code>: Optional starting value.</li><li><code>modulo::T = typemax(T)</code>: Optional modulo value, applied independently to the sum and the sum-of-sums after each block is summed.</li><li><code>blocksize::Integer = 1</code>: Optional block size for summing before applying the modulo operation. <code>blocksize</code> should be chosen with <code>modulo</code>, <code>T</code>, and <code>eltype(data)</code> in mind to make sure the sum operation does not overflow.</li></ul><p>Predefined convenience functions are <code>fletcher16</code>, <code>fletcher32</code>, and <code>fletcher64</code> for the standard modulo value of <code>typemax(T)</code> shifted right half the number of bits in the checksum, and <code>fletcher16a</code>, <code>fletcher32a</code>, and <code>fletcher64a</code> for the alternate modulo value of <code>1</code> left shifted half the number of bits in the checksum.</p><p>See also: <a href="#SimpleChecksums.adler32">adler32</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/reallyasi9/SimpleChecksums.jl/blob/c4030151fbee5988e19050daae6fe4785b6fac41/src/fletcher.jl#L7-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleChecksums.sysv_checksum" href="#SimpleChecksums.sysv_checksum"><code>SimpleChecksums.sysv_checksum</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sysv_checksum(UInt16, data, init::UInt16 = zero(UInt16))</code></pre><p>Compute a hash of <code>data</code> using the method defined in SYS-V&#39;s sum utility (and implemented in the GNU sum program).</p><p>The SYS-V checksum computes a 16-bit checksum value using a simple 32-bit additive sum, then folding the sum into a 16-bit number by adding the low 16 bits to the high 16 bits (shifted right by 16 bits). This fold is performed twice to guarantee the result is a 16-bit number. Unlike the SYS-V and GNU implementations, the sum in this implementation is allowed to overflow, which resets the sum to zero (SYS-V and GNU will raise an error instead).</p><p>This function is very fast but suffers from many collisions. Flaws to keep in mind are:</p><ol><li>zero values anywhere in <code>data</code> do not affect the checksum value at all (unless the initial value is set to something other than zero); and</li><li>the order of the data can be permuted without affecting the checksum value.</li></ol><p><strong>Arguments</strong></p><ul><li><code>data</code>: A single <code>Unsigned</code> value or an iterator of values.</li><li><code>init::UInt16 = zero(UInt16)</code>: Optional starting value.</li></ul><p>Predefined convenience function is <code>sysv16</code>.</p><p>See also: <code>additive16</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/reallyasi9/SimpleChecksums.jl/blob/c4030151fbee5988e19050daae6fe4785b6fac41/src/sysv.jl#L5-L23">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.3.0 on <span class="colophon-date" title="Wednesday 6 March 2024 21:48">Wednesday 6 March 2024</span>. Using Julia version 1.10.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
