var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = SimpleChecksums","category":"page"},{"location":"#SimpleChecksums","page":"Home","title":"SimpleChecksums","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for SimpleChecksums.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Synopsis","page":"Home","title":"Synopsis","text":"","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"SimpleChecksums\")","category":"page"},{"location":"#Use","page":"Home","title":"Use","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using SimpleChecksums\n\ndata = UInt8.(0:255);\n\n# super-simple sums:\n@assert additive_checksum(UInt16, data) == additive16(data) == 0x7f80\n@assert additive_checksum(UInt32, data) == additive32(data) == 0x00007f80\n@assert additive_checksum(UInt64, data) == additive64(data) == 0x0000000000007f80\n\n# BSD and SYS-V checksums from GNU sum utility:\n@assert bsd_checksum(UInt16, data) == bsd16(data) == 0x0200\n@assert sysv_checksum(UInt16, data) == sysv16(data) == 0x7f80\n\n# Fletcher's and Adler's checksums:\n@assert fletcher_checksum(UInt16, data) == fletcher16(data) == 0x5500\n@assert fletcher_checksum(UInt32, data) == fletcher32(data) == 0xaaaa7f80\n@assert fletcher_checksum(UInt64, data) == fletcher64(data) == 0x002aaa8000007f80\n\n@assert fletcher_checksum(UInt16, data, UInt16(0), 0x100) == fletcher16a(data) == 0x8080\n@assert fletcher_checksum(UInt32, data, UInt32(0), 0x10000) == fletcher32a(data) == 0xaa807f80\n@assert fletcher_checksum(UInt64, data, UInt64(0), 0x100000000) == fletcher64a(data) == 0x002aaa8000007f80\n\n@assert fletcher_checksum(UInt32, data, UInt32(1), UInt32(65521), 5552) == adler32(data) == 0xadf67f81","category":"page"},{"location":"#Why?","page":"Home","title":"Why?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Checksums are small summaries of data that can be used to detect errors introduced to the data during transmission or storage. In modern times, checksums have largely been replaced with cryptographic hashes like MD5 and SHA, but these functions and the computational power required to compute them in a reasonable amount of time did not exist when many of the data transmission and storage standards we use today were invented. If we want to use the checksums that appear in these standards in Julia code, it helps to have a standard library to compute them correctly and efficiently.","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you are building a new data transmission or storage standard and need a way to check for errors, consider using a cryptographic hash like SHA, or at least a better error-detecting code like CRC, before choosing any of these functions.","category":"page"},{"location":"#API","page":"Home","title":"API","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modules = [SimpleChecksums]","category":"page"},{"location":"#SimpleChecksums.additive16","page":"Home","title":"SimpleChecksums.additive16","text":"additive16(data, [init, modulo])\n\nAlias of additive_checksum(UInt16, data, init, modulo).\n\n\n\n\n\n","category":"function"},{"location":"#SimpleChecksums.additive32","page":"Home","title":"SimpleChecksums.additive32","text":"additive32(data, [init, modulo])\n\nAlias of additive_checksum(UInt32, data, init, modulo).\n\n\n\n\n\n","category":"function"},{"location":"#SimpleChecksums.additive64","page":"Home","title":"SimpleChecksums.additive64","text":"additive64(data, [init, modulo])\n\nAlias of additive_checksum(UInt64, data, init, modulo).\n\n\n\n\n\n","category":"function"},{"location":"#SimpleChecksums.additive_checksum-Union{Tuple{T}, Tuple{Type{T}, Any}, Tuple{Type{T}, Any, Unsigned}, Tuple{Type{T}, Any, Unsigned, T}} where T<:Unsigned","page":"Home","title":"SimpleChecksums.additive_checksum","text":"additive_checksum(T, data, init::T = zero(T), modulo::T = typemax(T)) where {T<:Unsigned}\n\nCompute a simple additive hash of the values in data.\n\nSums all the values in data, then computes modulo modulo, optionally starting from init instead of zero. Sums are allowed to overflow, which resets the sum to zero.\n\nThis function is extremely fast but suffers from many collisions. Flaws to keep in mind are:\n\nzero values in data do not affect the checksum value at all;\nthe order of the values in data can be permuted without changing the checksum value; and\nbecause of the modulo operation, the checksum of all zeros is equal to the checksum of all modulo values.\n\nArguments\n\nT: An unsinged integer type.\ndata: A single Unsigned value or an iterator of values.\ninit::Unsigned = zero(T): Optional starting value.\nmodulo::T = typemax(T): A number to use as the modulo for addition. Typical choices are typemax(T) (the default) or some prime number close to but less than typemax(T).\n\nPredefined convenience functions are additive16, additive32, and additive64.\n\nSee also: sysv16 for a different way of folding the sum into a fixed number of bits.\n\n\n\n\n\n","category":"method"},{"location":"#SimpleChecksums.adler32","page":"Home","title":"SimpleChecksums.adler32","text":"adler32(data, init::Unsigned = one(UInt32))\n\nCompute Adler's 32-bit checksum.\n\nAdler's 32-bit checksum is the same as Fletcher's 32-bit checksum with a modulus of 65521 (the largest 16-bit prime) and an inital value of one. This is a strict improvement on fletcher16, but has a higher probability of collision, worse likelihood of error detection, and is slower than fletcher32. Prefer fletcher32 instead.\n\n\n\n\n\n","category":"function"},{"location":"#SimpleChecksums.bsd16","page":"Home","title":"SimpleChecksums.bsd16","text":"bsd16(data, [init])\n\nAlias of bsd_checksum(UInt16, data, init).\n\n\n\n\n\n","category":"function"},{"location":"#SimpleChecksums.bsd_checksum","page":"Home","title":"SimpleChecksums.bsd_checksum","text":"bsd_checksum(UInt16, data, init::UInt16 = zero(UInt16))\n\nCompute a hash of data using the method defined in BSD's sum utility (and implemented in the GNU sum program).\n\nThe BSD checksum computes a 16-bit checksum value by bit-rotating the checksum value from the previous step to the right by 1 bit, then adding the next value from data and repeating. Sums are allowed to overflow, which resets the sum to zero.\n\nThis function is fast but suffers from many collisions. Flaws to keep in mind are:\n\nzero values at the beginning of data do not affect the checksum value at all (unless the initial value is set to something other than zero); and\nruns of zeros in data that are multiples of 16 in length do not affect the checksum value at all.\n\nArguments\n\ndata: A single Unsigned value or an iterator of values.\ninit::UInt16 = zero(UInt16): Optional starting value.\n\nPredefined convenience function is bsd16.\n\n\n\n\n\n","category":"function"},{"location":"#SimpleChecksums.fletcher16","page":"Home","title":"SimpleChecksums.fletcher16","text":"fletcher16(data, [init, modulo])\n\nAlias of fletcher_checksum(UInt16, data, init, modulo=0x00ff, blocksize=380368696).\n\n\n\n\n\n","category":"function"},{"location":"#SimpleChecksums.fletcher16a","page":"Home","title":"SimpleChecksums.fletcher16a","text":"fletcher16a(data, [init, modulo])\n\nAlias of fletcher_checksum(UInt16, data, init, modulo=0x0100, blocksize=379625061).\n\n\n\n\n\n","category":"function"},{"location":"#SimpleChecksums.fletcher32","page":"Home","title":"SimpleChecksums.fletcher32","text":"fletcher32(data, [init, modulo])\n\nAlias of fletcher_checksum(UInt32, data, init, modulo=0x0000ffff, blocksize=23726746).\n\n\n\n\n\n","category":"function"},{"location":"#SimpleChecksums.fletcher32a","page":"Home","title":"SimpleChecksums.fletcher32a","text":"fletcher32a(data, [init, modulo])\n\nAlias of fletcher_checksum(UInt32, data, init, modulo=0x00010000, blocksize=23726565).\n\n\n\n\n\n","category":"function"},{"location":"#SimpleChecksums.fletcher64","page":"Home","title":"SimpleChecksums.fletcher64","text":"fletcher64(data, [init, modulo])\n\nAlias of fletcher_checksum(UInt64, data, init, modulo=0x00000000ffffffff, blocksize=92681).\n\n\n\n\n\n","category":"function"},{"location":"#SimpleChecksums.fletcher64a","page":"Home","title":"SimpleChecksums.fletcher64a","text":"fletcher64a(data, [init, modulo])\n\nAlias of fletcher_checksum(UInt64, data, init, modulo=0x0000000100000000, blocksize=92681).\n\n\n\n\n\n","category":"function"},{"location":"#SimpleChecksums.fletcher_checksum-Union{Tuple{T}, Tuple{Type{T}, Any}, Tuple{Type{T}, Any, Unsigned}, Tuple{Type{T}, Any, Unsigned, T}, Tuple{Type{T}, Any, Unsigned, T, Integer}} where T<:Unsigned","page":"Home","title":"SimpleChecksums.fletcher_checksum","text":"fletcher_checksum(T, data, init::T = zero(T), modulo::T = typemax(T), blocksize::Integer = 1)\n\nCompute a hash of data using Fletcher's checksum.\n\nFletcher's checksum computes two values: c0, a running sum of values modulo some number, and c1, a running sum of c0 values modulo some number. The two values are contatenated bitwise into a single unsigned integer.\n\nThis function is fast and good at detecting small errors. Flaws to keep in mind are:\n\nzero values at the beginning of data do not affect the checksum value at all (unless the initial value is set to something other than zero); and\nthe worst-case performance for this algorithm occurs when data are truly random, but all errors of up to 2 bits are detected on all runs of data of length modulo * (sizeof(T)*4) bits.\n\nArguments\n\nT: An unsinged integer type.\ndata: A single Unsigned value or an iterator of values.\ninit::Unsigned = zero(T): Optional starting value.\nmodulo::T = typemax(T): Optional modulo value, applied independently to the sum and the sum-of-sums after each block is summed.\nblocksize::Integer = 1: Optional block size for summing before applying the modulo operation. blocksize should be chosen with modulo, T, and eltype(data) in mind to make sure the sum operation does not overflow.\n\nPredefined convenience functions are fletcher16, fletcher32, and fletcher64 for the standard modulo value of typemax(T) shifted right half the number of bits in the checksum, and fletcher16a, fletcher32a, and fletcher64a for the alternate modulo value of 1 left shifted half the number of bits in the checksum.\n\nSee also: adler32.\n\n\n\n\n\n","category":"method"},{"location":"#SimpleChecksums.sysv16","page":"Home","title":"SimpleChecksums.sysv16","text":"sysv16(data, [init])\n\nAlias of sysv_checksum(UInt16, data, init).\n\n\n\n\n\n","category":"function"},{"location":"#SimpleChecksums.sysv_checksum","page":"Home","title":"SimpleChecksums.sysv_checksum","text":"sysv_checksum(UInt16, data, init::UInt16 = zero(UInt16))\n\nCompute a hash of data using the method defined in SYS-V's sum utility (and implemented in the GNU sum program).\n\nThe SYS-V checksum computes a 16-bit checksum value using a simple 32-bit additive sum, then folding the sum into a 16-bit number by adding the low 16 bits to the high 16 bits (shifted right by 16 bits). This fold is performed twice to guarantee the result is a 16-bit number. Unlike the SYS-V and GNU implementations, the sum in this implementation is allowed to overflow, which resets the sum to zero (SYS-V and GNU will raise an error instead).\n\nThis function is very fast but suffers from many collisions. Flaws to keep in mind are:\n\nzero values anywhere in data do not affect the checksum value at all (unless the initial value is set to something other than zero); and\nthe order of the data can be permuted without affecting the checksum value.\n\nArguments\n\ndata: A single Unsigned value or an iterator of values.\ninit::UInt16 = zero(UInt16): Optional starting value.\n\nPredefined convenience function is sysv16.\n\nSee also: additive16.\n\n\n\n\n\n","category":"function"}]
}
