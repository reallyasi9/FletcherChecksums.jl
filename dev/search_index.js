var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = SimpleChecksums","category":"page"},{"location":"#SimpleChecksums","page":"Home","title":"SimpleChecksums","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for SimpleChecksums.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [SimpleChecksums]","category":"page"},{"location":"#SimpleChecksums.additive_checksum-Union{Tuple{T}, Tuple{Type{T}, Any}, Tuple{Type{T}, Any, Unsigned}, Tuple{Type{T}, Any, Unsigned, T}} where T<:Unsigned","page":"Home","title":"SimpleChecksums.additive_checksum","text":"additive_checksum(T, data, init::T = zero(T), modulo::T = typemax(T)) where {T<:Unsigned}\n\nCompute a simple additive hash of the values in data.\n\nSums all the values in data, then computes modulo modulo, optionally starting from init instead of zero. Sums are allowed to overflow, which resets the sum to zero.\n\nThis function is extremely fast but suffers from many collisions. Flaws to keep in mind are:\n\nzero values in data do not affect the checksum value at all;\nthe order of the values in data can be permuted without changing the checksum value; and\nbecause of the modulo operation, the checksum of all zeros is equal to the checksum of all modulo values.\n\nArguments\n\nT: An unsinged integer type.\ndata: A single Unsigned value or an iterator of values.\ninit::Unsigned = zero(T): Optional starting value.\nmodulo::T = typemax(T): A number to use as the modulo for addition. Typical choices are typemax(T) (the default) or some prime number close to but less than typemax(T).\n\nPredefined convenience functions are additive16, additive32, and additive64.\n\nSee also: sysv16 for a different way of folding the sum into a fixed number of bits.\n\n\n\n\n\n","category":"method"},{"location":"#SimpleChecksums.bsd_checksum","page":"Home","title":"SimpleChecksums.bsd_checksum","text":"bsd_checksum(UInt16, data, init::UInt16 = zero(UInt16))\n\nCompute a hash of data using the method defined in BSD's sum utility (and implemented in the GNU sum program).\n\nThe BSD checksum computes a 16-bit checksum value by bit-rotating the checksum value from the previous step to the right by 1 bit, then adding the next value from data and repeating. Sums are allowed to overflow, which resets the sum to zero.\n\nThis function is fast but suffers from many collisions. Flaws to keep in mind are:\n\nzero values at the beginning of data do not affect the checksum value at all (unless the initial value is set to something other than zero); and\nruns of zeros in data that are multiples of 16 in length do not affect the checksum value at all.\n\nArguments\n\ndata: A single Unsigned value or an iterator of values.\ninit::UInt16 = zero(UInt16): Optional starting value.\n\nPredefined convenience function is bsd16.\n\n\n\n\n\n","category":"function"},{"location":"#SimpleChecksums.sysv_checksum","page":"Home","title":"SimpleChecksums.sysv_checksum","text":"sysv_checksum(UInt16, data, init::UInt16 = zero(UInt16))\n\nCompute a hash of data using the method defined in SYS-V's sum utility (and implemented in the GNU sum program).\n\nThe SYS-V checksum computes a 16-bit checksum value using a simple 32-bit additive sum, then folding the sum into a 16-bit number by adding the low 16 bits to the high 16 bits (shifted right by 16 bits). This fold is performed twice to guarantee the result is a 16-bit number. Unlike the SYS-V and GNU implementations, the sum in this implementation is allowed to overflow, which resets the sum to zero (SYS-V and GNU will raise an error instead).\n\nThis function is very fast but suffers from many collisions. Flaws to keep in mind are:\n\nzero values anywhere in data do not affect the checksum value at all (unless the initial value is set to something other than zero); and\nthe order of the data can be permuted without affecting the checksum value.\n\nArguments\n\ndata: A single Unsigned value or an iterator of values.\ninit::UInt16 = zero(UInt16): Optional starting value.\n\nPredefined convenience function is sysv16.\n\nSee also: additive16.\n\n\n\n\n\n","category":"function"}]
}
